name: "Deploy GHCR image to AKS (reusable)"

on:
  workflow_call:
    inputs:
      ghcr_image:
        description: "Full image ref to deploy (e.g. ghcr.io/OWNER/kong-gateway:TAG)"
        required: true
        type: string
      # AKS 接続情報
      resource_group:
        description: "AKS resource group name"
        required: true
        type: string
      cluster_name:
        description: "AKS cluster name"
        required: true
        type: string
      # 既存の Kong DP Deployment/Namespace/コンテナ名
      namespace:
        description: "Kubernetes namespace"
        required: false
        default: "kong"
        type: string
      deployment_name:
        description: "Kong DP Deployment name"
        required: false
        default: "kong"
        type: string
      container_name:
        description: "Container name in the Deployment"
        required: false
        default: "proxy"
        type: string
      # Private GHCR のときだけ true にする
      create_pull_secret:
        description: "Create/Update docker-registry Secret for GHCR"
        required: false
        default: "true"
        type: string
      pull_secret_name:
        description: "Name of the imagePullSecret in the namespace"
        required: false
        default: "ghcr-secret"
        type: string
    secrets:
      AZURE_CREDENTIALS:
        required: true
      # private pull 時のみ設定（PAT: read:packages）
      GHCR_USERNAME:
        required: false
      GHCR_TOKEN:
        required: false
      KONNECT_TOKEN:
        required: true
    outputs:
      dp_external_ip:
        description: "Kong DP Service EXTERNAL-IP (if assigned)"
        value: ${{ jobs.deploy.outputs.dp_external_ip }}
      dp_external_hostname:
        description: "Kong DP Service external hostname (if any)"
        value: ${{ jobs.deploy.outputs.dp_external_hostname }}
      dp_service_name:
        description: "Kong DP Service name"
        value: ${{ jobs.deploy.outputs.dp_service_name }}

permissions:
  id-token: write  # OIDC で Azure にログイン
  contents: read

jobs:
  deploy:
    name: "Set image & rollout"
    runs-on: ubuntu-latest
    env:
      KONNECT_API: https://us.api.konghq.com/v2

    steps:
   
      - name: "Azure login"
        uses: azure/login@v1.4.3
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: "Set AKS context"
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ inputs.resource_group }}
          cluster-name:   ${{ inputs.cluster_name }}

      - name: "Create/Update GHCR pull secret (optional)"
        if: ${{ inputs.create_pull_secret == 'true' }}
        run: |
          kubectl create namespace "${{ inputs.namespace }}" --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n "${{ inputs.namespace }}" delete secret "${{ inputs.pull_secret_name }}" --ignore-not-found
          kubectl -n "${{ inputs.namespace }}" create secret docker-registry "${{ inputs.pull_secret_name }}" \
            --docker-server=ghcr.io \
            --docker-username="${{ secrets.GHCR_USERNAME }}" \
            --docker-password="${{ secrets.GHCR_TOKEN }}" \
            --docker-email="noreply@example.com"
        # ↑ Kubernetes の docker-registry Secret 作成。[8](https://kubernetes.io/docs/reference/kubectl/generated/kubectl_create/kubectl_create_secret_docker-registry/)

      - name: Set up dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq openssl

      - name: Get Control Plane ID and upload TLS certs
        id: get_cp
        run: |
          CP_ID=$(curl -s -X GET \
            -H "Authorization: Bearer ${{ secrets.KONNECT_TOKEN }}" \
            "${KONNECT_API}/control-planes" \
            | jq -r --arg name "${{ vars.CONTROL_PLANE }}" '.data[] | select(.name==$name) | .id')
          mkdir certs
          openssl req -new -x509 -nodes -newkey rsa:2048 \
            -subj "/CN=kongdp/C=US" \
            -keyout ./certs/tls.key -out ./certs/tls.crt -days 3650
          export CERT=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' ./certs/tls.crt)
          curl -sX POST \
            -H "Authorization: Bearer ${{ secrets.KONNECT_TOKEN }}" \
            ${KONNECT_API}/control-planes/${CP_ID}/dp-client-certificates \
            --json '{"cert":"'"$CERT"'"}'
          CP_ENDPOINT=$(curl -s -X GET \
            -H "Authorization: Bearer ${{ secrets.KONNECT_TOKEN }}" \
            "${KONNECT_API}/control-planes/${CP_ID}" \
            | jq -r '.config.control_plane_endpoint')
          CP_ENDPOINT=$(sed "s@https://@@" <<< $CP_ENDPOINT)
          TP_ENDPOINT=$(curl -s -X GET \
            -H "Authorization: Bearer ${{ secrets.KONNECT_TOKEN }}" \
            "${KONNECT_API}/control-planes/${CP_ID}" \
            | jq -r '.config.telemetry_endpoint')
          TP_ENDPOINT=$(sed "s@https://@@" <<< $TP_ENDPOINT)
          echo "tp_endpoint=$TP_ENDPOINT" >> "$GITHUB_OUTPUT"
          echo "cp_endpoint=$CP_ENDPOINT" >> "$GITHUB_OUTPUT"

      - name: Create Kubernetes namespace and TLS secret
        run: |
          kubectl create ns "${{ inputs.namespace }}" || true
          kubectl create secret tls kong-cluster-cert -n "${{ inputs.namespace }}" \
            --cert=./certs/tls.crt \
            --key=./certs/tls.key \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: "Patch imagePullSecrets to ServiceAccount (optional)"
        if: ${{ inputs.create_pull_secret == 'true' }}
        run: |
          # 既定の default SA に imagePullSecrets を足す（必要なら専用SAへ変更）
          kubectl -n "${{ inputs.namespace }}" patch serviceaccount default \
            -p "{\"imagePullSecrets\": [{\"name\": \"${{ inputs.pull_secret_name }}\"}]}" \
            --type=merge || true
        # ※ 既存 Deployment 側に imagePullSecrets が設定済みならこのパッチは不要です。
        #   Private pull の一般的なやり方を参考として提示。[9](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/)

      - name: Generate values.yaml (from ghcr_image)
        run: |
          set -euo pipefail

          IMG="${{ inputs.ghcr_image }}"

          REPO=""
          TAG=""
          DIGEST=""

          if [[ "$IMG" == *"@"* ]]; then
            # 例) ghcr.io/owner/kong-gateway@sha256:abcdef...
            REPO="${IMG%@*}"
            DIGEST="${IMG#*@}"
          elif [[ "$IMG" == *":"* ]]; then
            # 例) ghcr.io/owner/kong-gateway:3.11
            TAG="${IMG##*:}"
            REPO="${IMG%:*}"
          else
            # タグ未指定の場合は latest を既定に
            REPO="$IMG"
            TAG="latest"
          fi

          echo "Resolved image:"
          echo "  repository: $REPO"
          if [[ -n "$DIGEST" ]]; then
            echo "  digest    : $DIGEST"
          else
            echo "  tag       : $TAG"
          fi

          # 1) 先にプレースホルダ込みで YAML 全体を書き出す（cat <<EOF）
          cat > ./values.yaml <<EOF
          image:
            repository: __IMAGE_REPO__
          __IMAGE_TAG_OR_DIGEST__
            pullSecrets:
              - ${{ inputs.pull_secret_name }}
            pullPolicy: Always

          secretVolumes:
            - kong-cluster-cert

          admin:
            enabled: false

          env:
            role: data_plane
            database: "off"
            cluster_mtls: pki
            cluster_control_plane: ${{ steps.get_cp.outputs.cp_endpoint }}:443
            cluster_server_name: ${{ steps.get_cp.outputs.cp_endpoint }}
            cluster_telemetry_endpoint: ${{ steps.get_cp.outputs.tp_endpoint }}:443
            cluster_telemetry_server_name: ${{ steps.get_cp.outputs.tp_endpoint }}
            cluster_cert: /etc/secrets/kong-cluster-cert/tls.crt
            cluster_cert_key: /etc/secrets/kong-cluster-cert/tls.key
            lua_ssl_trusted_certificate: system
            konnect_mode: "on"
            vitals: "off"
            nginx_worker_processes: "1"
            upstream_keepalive_max_requests: "100000"
            nginx_http_keepalive_requests: "100000"
            proxy_access_log: "off"
            dns_stale_ttl: "3600"
            router_flavor: expressions
            KONG_PLUGINS: bundled,prometheus

          ingressController:
            enabled: false
            installCRDs: false

          resources:
            requests:
              cpu: 1
              memory: "2Gi"

          serviceMonitor:
            enabled: true
            labels:
              release: prometheus

          manager:
            enabled: false
          EOF

          # 2) プレースホルダを tag または digest に置換（インデントを崩さない）          
          # repository
          sed -i "s|__IMAGE_REPO__|${REPO}|g" ./values.yaml
          # tag または digest を必ず文字列で挿入
          if [[ -n "$DIGEST" ]]; then
            # ダイジェストはコロンを含むため YAML では引用する
            sed -i 's|__IMAGE_TAG_OR_DIGEST__|  digest: "'"$DIGEST"'"|g' ./values.yaml
          else
            sed -i 's|__IMAGE_TAG_OR_DIGEST__|  tag: "'"$TAG"'"|g' ./values.yaml
          fi

          echo "----- values.yaml -----"
          cat ./values.yaml

      - name: Deploy with Helm
        run: |
          helm repo add kong https://charts.konghq.com
          helm repo update
          helm upgrade -i "${{ inputs.deployment_name }}" kong/kong -n "${{ inputs.namespace }}" --values ./values.yaml --debug --wait

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: kong-dp-config
          path: |
            ./values.yaml
            ./certs/tls.crt
            ./certs/tls.key
            
      - name: "Wait for rollout"
        run: |
          kubectl -n "${{ inputs.namespace }}" rollout status \
            deployment/${{ inputs.deployment_name }}-kong \
            --timeout=10m
        # ↑ ローリング更新が完了するまで待機（readiness 成功まで）。[11](https://kubernetes.io/docs/reference/kubectl/generated/kubectl_rollout/)[12](https://stackoverflow.com/questions/68540187/kubectl-rollout-status-when-the-command-complete)
        
      - name: "Show pods"
        if: always()
        run: |
          kubectl -n "${{ inputs.namespace }}" get deploy/${{ inputs.deployment_name }}-kong -o wide
          kubectl -n "${{ inputs.namespace }}" get pods -o wide --sort-by=.metadata.creationTimestamp

      - name: Resolve DP global endpoint (Service EXTERNAL-IP)
        id: dp_endpoint
        run: |
          set -euo pipefail
          NS="${{ inputs.namespace }}"
          REL="${{ inputs.deployment_name }}"    # = Helm リリース名（例: kong-dp-poc-bookinfo）

          # 1) Service名の解決：Kongチャートは <release>-kong-proxy を作るのが既定
          #    ラベル解決に失敗したら名前規約にフォールバック
          SVC="$(kubectl -n "$NS" get svc \
            -l "app.kubernetes.io/instance=${REL},app.kubernetes.io/name=kong,app.kubernetes.io/component=proxy" \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)"

          if [ -z "$SVC" ]; then
            SVC="${REL}-kong-proxy"
          fi

          echo "Target Service: ${NS}/${SVC}"

          # 2) EXTERNAL-IP / hostname の払い出し待ち（最大 10 分 / 60 回）
          IP=""; HOST=""
          for i in $(seq 1 60); do
            IP="$(kubectl -n "$NS" get svc "$SVC" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)"
            HOST="$(kubectl -n "$NS" get svc "$SVC" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)"
            if [ -n "$IP" ] || [ -n "$HOST" ]; then
              break
            fi
            echo "Waiting for EXTERNAL-IP ... (${i}/60)"; sleep 10
          done

          if [ -z "$IP" ] && [ -n "$HOST" ]; then
            echo "Resolved hostname: $HOST"
          elif [ -n "$IP" ]; then
            echo "Resolved EXTERNAL-IP: $IP"
          else
            echo "ERROR: EXTERNAL-IP/hostname not assigned yet."
            echo "Debug SVC:"; kubectl -n "$NS" get svc "$SVC" -o wide || true
            exit 1
          fi

          # 3) 出力（Step outputs）
          echo "external_ip=${IP}" >> "$GITHUB_OUTPUT"
          echo "external_hostname=${HOST}" >> "$GITHUB_OUTPUT"
          echo "service_name=${SVC}" >> "$GITHUB_OUTPUT"

    outputs:
      dp_external_ip:       ${{ steps.dp_endpoint.outputs.external_ip }}
      dp_external_hostname: ${{ steps.dp_endpoint.outputs.external_hostname }}
      dp_service_name:      ${{ steps.dp_endpoint.outputs.service_name }}
